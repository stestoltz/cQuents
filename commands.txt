----------| Formats

-----| Program Format
[[literals][parameters]<mode>]<sequence>

-----| Literal Format
[literals][|join[|backliterals]]

-----| Parameter Formats
[$|=][arg[,arg]...]
["]
[#][frontinput[,frontinput]...][|[backinput[,backinput]...]]

-----| Sequence Format
<item>[,item]

-----| Input
input = frontinput + userinput + backinput
Input is expected if the input fetchers (A-E) are used in the program. If there is an extra input afterwards, it is called n. If the input lengths do not match up, an error occurs.

-----| Function Format
<name>[parameter[, parameter]...][)]

----------| Characters

-----| Literal Selectors
 @   | Escapes the next character as a string literal
 '   | Quote to capture string literals
 
-----| Parameters (see format above)
 #   | Default Input: adds input to the user's
 =   | Sequence Start: specifies the first terms of the sequence
 $   | Starting Index: specifies the start index (default is 1)
 "   | Stringify: join on empty string, treat n as index in string, not in list

-----| Modes
 :   | Sequence 1: If n, output the nth term. Otherwise, output the whole sequence
 ::  | Sequence 2: If n, output the sequence up to and including the nth term. Otherwise, TODO
 ;   | Series: If n, output the sum of the sequence up to and including n. Otherwise, TODO (output convergent sum of sequence)
 ?   | Query: If there is n, output true if n is in the sequence, and false if n is not in the sequence. (Currently assumes strictly increasing). Otherwise, ignore sequence.
 ??  | Reverse Query: Same as query, but with outputs swapped.
 ;;  | TODO: Closest
 
-----| Numbers
Numbers are formed using . and 0-9 as would be expected. Use negation (-) for negative numbers.

-----| Variables
 $   | Current index in sequence
 n   | Target: n as defined above, if given
 A   | First input:     input[0]
 B   | Second input:    input[1]
 C   | Third input:     input[2]
 z   | Previous item in sequence: sequence[-1] || 0
 y   | Second previous item in sequence: sequence[-2] || 0
 x   | Third previous item in sequence: sequence[-3] || 0

-----| Unary Operators
 +   | Plus:             +x
 -   | Negation:         -x
 ~   | Bitwise invert:   ~x
 _l  | Rotate left:      _lx
 _r  | Rotate right:     _rx
 _+  | Add one:          _+x
 _-  | Subtract one:     _-x

-----| Post-Unary Operators
 !   | Factorial:        x!
 
-----| Operators
 %   | Modulus:          x%y
 *   | Multiplication:   x*y
 +   | Addition:         x+ 
 -   | Subtraction:      x-y
 /   | Division:         x/y
 _/  | Integer (floor) division: x_/y
 ^   | Exponent:         x^y
 ~   | Concatenation:    x~y
 e   | Scientific Notation: xey
 _|  | Bitwise or:       x_|y
 _n  | Bitwise nor:      x_ny
 _^  | Bitwise xor:      x_^y
 _x  | Bitwise xnor:     x_ny
 _&  | Bitwise and:      x_&y
 _N  | Bitwise nand:     x_Ny
 _<  | Bitwise left shift: x_<y
 _>  | Bitwise right shift: x_>y

-----| Functions
 a   | Absolute value:   ax)
 c   | Ceil:             cx)
 f   | Factorial:        fx)
 F   | Floor:            Fx)
 l   | Logarithm:        lx[,y]) (default y: _e)
 L   | Length:           Lx[,y]) (if y exists, include "." in count)
 O   | OEIS:             O<seqNum><seqLetter>x)
 p   | Next Prime (exclusive): px)
 r   | Root:             rx[,y]) (default y: 2)
 R   | Round:            Rx)
 X   | Exp:              Xx)
 \c  | Cosine:           \cx)
 \l  | Log 10:           \lx)
 \r  | Reverse:          \rx[,y]) (if y exists, include "." in reversal)
 \R  | Rotate:           \Rx,y[,z]) (+y goes right, -y goes left) (if z exists, move ".")
 \s  | Sine:             \sx)
 \t  | Tangent:          \tx)

-----| Constants
 `c  | Catalan's constant: Sum of 1/1^2 - 1/3^2 + 1/5^2 - 1/7^2 + ...
 `e  | e: Base of the natural logarithm
 `g  | Golden Ratio: .5 * (sqrt(5) + 1)
 `G  | Glaisher-Kinkelin constant
 `k  | Khinchin's constant
 `p  | pi: Circumference divided by diameter in a perfect circle
 `y  | Euler-Mascheroni constant: limiting difference between the harmonic series and the natural logarithm
 
 #TODO: GCD, LCM, toBase, more trig functions, 

-----| All ASCII
 \n  | (Literal newline) start new program on next line; can be called with \0 to \9
' '  | (Space) 
 !   | Factorial
 "   | (param stringify)
 #   | (param default input)
 $   | current index
 %   | modulus
 &   |
 '   | literal quotes
 (   | Opening parenthesis.
 )   | Closing parenthesis for functions or opening parenthsis. Can be left off of program if before EOF or newline.
 *   | multiplication
 +   | addition
 ,   | item/term separator
 -   | subtraction
 .   | decimal point
 0   | zero
 1   | one
 2   | two
 3   | three
 4   | four
 5   | five
 6   | six
 7   | seven
 8   | eight
 9   | nine
 :   | (mode series)
 ;   | (mode sum), function separator
 <   |
 =   | (param start)
 >   |
 ?   | (mode query)
 @   | literal escape
 A   | first input
 B   | second input
 C   | third input
 D   |
 E   |
 F   | floor
 G   | #GCD
 H   |
 I   | input func
 J   |
 K   |
 L   | length
 M   | #LCM
 N   |
 O   |
 P   | previous func
 Q   |
 R   | round
 S   |
 T   | ceiling
 U   |
 V   |
 W   |
 X   | third previous term
 Y   | second previous term
 Z   | previous term
 [   |
 \   | extra builtins start
 ]   |
 ^   | exponentiation
 _   | extra operators start
 `   | constants start
 a   | first line
 b   | second line
 c   | third line
 d   | lines func
 e   | scientific notation
 f   | factorial
 g   |
 h   |
 i   |
 j   |
 k   |
 l   | logarithm (default base e)
 m   |
 n   | input n
 o   |
 p   | next prime
 q   |
 r   | root
 s   |
 t   | ten
 u   |
 v   | absolute value
 w   |
 x   | exp
 y   |
 z   |
 {   |
 |   | (meta separator)
 }   |
 ~   | concatenation
